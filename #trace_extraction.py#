import numpy as np
import matplotlib.pyplot as plt
from astropy.io import fits
import sys,os
from scipy import interpolate,optimize,stats
from scipy.optimize import curve_fit
from scipy.interpolate import griddata
import multiprocessing as mp
import concurrent.futures




def poly2D(x, y, coeffs):
    order = int(np.sqrt(len(coeffs))) - 1
    z = np.zeros_like(x)
    index = 0
    for i in range(order + 1):
        for j in range(order + 1 - i):
            z += coeffs[index] * (x ** i) * (y ** j)
            index += 1
    return z


# Define the function for curve_fit
def fit_func(data, *coeffs):
    x, y = data
    return poly2D(x, y, coeffs)

     
def sigma_clipped_polyfit(x, y, degree, sigma=3.0, max_iter=5):
    """
    Perform a sigma-clipped polynomial fit to data.

    Parameters:
    x : array_like
        x-coordinates of the data.
    y : array_like
        y-coordinates of the data.
    degree : int
        Degree of the polynomial to fit.
    sigma : float, optional
        Number of standard deviations to use for clipping.
    max_iter : int, optional
        Maximum number of iterations for the sigma clipping.

    Returns:
    p : ndarray
        Polynomial coefficients, highest power first.
    """

    # Initial fit
    x = np.array(x)
    y = np.array(y)
    mask = x == x
    mask *= y == y
    x = x[mask]
    y = y[mask]

    p = np.polyfit(x, y, degree)
    
    for _ in range(max_iter):
        # Evaluate the polynomial
        y_fit = np.polyval(p, x)
        
        # Calculate residuals
        residuals = y - y_fit
        
        # Compute the standard deviation of the residuals
        std = np.std(residuals)
        
        # Identify inliers
        mask = np.abs(residuals) < sigma * std
        
        # Update x and y to only use inliers
        x_inliers = x[mask]
        y_inliers = y[mask]

        
        # Refit the polynomial
        p = np.polyfit(x_inliers, y_inliers, degree)
        
    return p

def psf(x0,x):
    """
    Gaussian PSF model
    """ 

    psfmodel = x0[2]*np.exp(-(x-x0[0])**2/x0[1]**2)+x0[3]*x+x0[4]
    return psfmodel

def computePSF(prof):
    """
    Fit of PSF model
    """ 

    x = np.arange(len(prof))

    xmax = x[np.nanargmax(prof)]
    
    def minfunc(x0):
        if abs(x0[0]-xmax) < 2 and x0[1] > 0 and x0[1] < 5:
            psfmodel = psf(x0,x)
            diff = np.nansum((psfmodel-prof)**2)
            return diff
        else:
            return np.inf
    
    x0 = [xmax,3.,np.nanmax(prof),0,0]
    x0 = optimize.fmin(minfunc,x0,disp=0)

    return x0




def trace(order,blocksize=10,debug=False):
    """
    Trace along stellar signal by a Gaussian fit along the spatial axis
    Wavelength axis is binned by width of blocksize pixels

    Operates on a 2D image of an order
    """

    
    i = 0
    gauss_fit_params = []
    while i < len(order[0]):
        prof = np.nanmedian(order[:,i:i+blocksize],axis=1)
        detection = np.nanmax(prof) / np.nanmedian(abs(np.diff(prof)))
        #print(detection)
        if detection > 50:
            x0 = computePSF(prof)
            x0 = [i]+list(x0)
            gauss_fit_params.append(x0)
        else:
            gauss_fit_params.append(np.ones(6)*np.nan)

        i += blocksize

    gauss_fit_params= np.array(gauss_fit_params)
    mask = gauss_fit_params[:,0]==gauss_fit_params[:,0]

    centroid = np.polyfit(gauss_fit_params[:,0][mask],gauss_fit_params[:,1][mask],2)
    centroid = np.polyval(centroid,np.arange(len(order[0])))
    invalidmask = np.arange(len(order[0])) > min(gauss_fit_params[:,0][mask])
    invalidmask *= np.arange(len(order[0])) < max(gauss_fit_params[:,0][mask])
    centroid[np.invert(invalidmask)] = 0

    #centroid = np.polyval(centroid,gauss_fit_params[:,0])
    
    fwhmextraction = np.polyfit(gauss_fit_params[:,0][mask],gauss_fit_params[:,2][mask],2)
    fwhmextraction = np.polyval(fwhmextraction,np.arange(len(order[0])))


    if debug:
        plt.subplot(311)
        plt.plot(gauss_fit_params[:,0],gauss_fit_params[:,1])
        plt.plot(np.arange(len(order[0])),centroid)
        plt.ylabel("Y")
        plt.subplot(312)
        plt.plot(gauss_fit_params[:,0],gauss_fit_params[:,2])
        plt.plot(np.arange(len(order[0])),fwhmextraction)
        plt.ylabel("FWHM")
        plt.subplot(313)
        plt.plot(gauss_fit_params[:,0],gauss_fit_params[:,3])
        plt.ylabel("Height")
        plt.show()

        plt.imshow(order,aspect='auto')
        plt.plot(np.arange(len(order[0])),centroid)
        plt.show()


    return gauss_fit_params[:,0],centroid,fwhmextraction,gauss_fit_params


def extract(order,order_error,centroid,fwhm,aperture=1.5,background_mask=5,unit='fwhm',bkorder=0,debug=False):
    """
    Function to extract along centroid
    
    unit is 'fwhm' or 'pixel' - 
    specifies if 'aperture' and 'background_mask' is measured as a 
    function of fwhm or in absolute pixel units
    
    """

    output_spectrum = []
    for i in range(len(order[0])):

        
        y = np.arange(len(order[:,i]))
        mask = order[:,i] == order[:,i]

        if sum(mask) > 0 and centroid[i] != 0: ### this avoids the first column where it's all nan
            if unit == 'fwhm':
                bkmask = abs(y-centroid[i])>fwhm[i]*background_mask
            else:
                bkmask = abs(y-centroid[i])>background_mask
                
            bkmask *= mask


            if bkorder >= 1:
                ### average background over ncolumns
                average_width = 1
                column_min = i-average_width
                column_max = i+average_width
                if column_min < 0:
                    i = 0
                if column_max > len(order[0]):
                    imax = len(order[0])

                spatial_axis = []
                background_flux_axis = []
                for n in np.arange(column_min,column_max):
                    spatial_axis += list(y[bkmask])
                    background_flux_axis += list(order[:,n][bkmask])

                ### perform iterative polyfit
                try:
                    bk = sigma_clipped_polyfit(spatial_axis,background_flux_axis, bkorder, sigma=2.0, max_iter=3)
                    bk = np.polyval(bk,y)
                    bkerror = np.sqrt(np.nansum(order_error[:,i][bkmask]**2))/sum(bkmask)
                except TypeError:
                    print("Bad column for background subtraction")
                    bk = np.zeros(len(y))
                    bkerror = np.nan
            else:
                bk = np.nanmedian(order[:,i][bkmask])*np.ones(len(order[:,i]))
                bkerror = np.sqrt(np.nansum(order_error[:,i][bkmask]**2))/sum(bkmask)

                

            if debug:
                plt.scatter(y,order[:,n])
                plt.scatter(spatial_axis,background_flux_axis)
                plt.plot(y,bk)
                plt.show()


            ### Extract flux of star
            if unit=='fwhm':
                aperture_i = fwhm[i]*aperture
            if unit=='pixel':
                aperture_i = aperture


            if True: 
                dist = abs((y-centroid[i]))
                mask = dist > aperture_i
                dist[mask] = aperture_i
                mask = dist < aperture_i-1
                dist[mask] = aperture_i-1
                dist -= aperture_i-1
                dist = 1-dist

                flux = np.nansum((order[:,i]-bk)*dist)
                fluxerror = np.sqrt(np.nansum((order_error[:,i]*dist)**2))
                bkerror = bkerror*np.nansum(dist)

            output_spectrum.append([flux,centroid[i],aperture_i,np.nanmean(bk),np.sqrt(fluxerror**2+bkerror**2),bkerror])
                

        else:
            output_spectrum.append([np.nan,np.nan,np.nan,np.nan,np.nan,np.nan])

    return np.array(output_spectrum)


def determine_trace(hdudata,debug=False):
    data = hdudata[1].data
    spatial_coord, centroid, fwhm, gauss_fit_params = trace(data)

